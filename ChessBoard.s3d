#ifndef _CHESSBOARD
#define _CHESSBOARD

#include "ChessPiece.s3d"
/*
—— a  b  c  d  e  f  g  h
8 ║56 57 58 59 60 61 62 63
7 ║48 49 50 51 52 53 54 55
6 ║40 41 42 43 44 45 46 47
5 ║32 33 34 35 36 37 38 39
4 ║24 25 26 27 28 29 30 31
3 ║16 17 18 19 20 21 22 23
2 ║ 8  9 10 11 12 13 14 15
1 ║ 0  1  2  3  4  5  6  7
—— a  b  c  d  e  f  g  h
*/
class ChessBoard
{
    var wPieces;
    var bPieces;

    var wMaterial;
    var bMaterial;
    var xMaterial;

    var corner;
    var dimension;

    var eatedCounters;

    var cbMatrix;

    var isDropping;

    Init();
    DrawPieces(flag);
    FindTouched(finger);
    DropPieces();
    GetPiecePosition(id);
    GetPieceFrom32id(id);
    DropToNewPosition(mov_piece);
    FreeMovePiece(id, pos);
    GetPosFromXY(p);
    IsValidDropPosition(id);
    EatPieceIn(pos);
    LegalMoves(piece);
    CanMoveTo(color, dest);

    CalcNewPos(pos, r, c,  result);
};

function ChessBoard::ChessBoard(c, d, wm, bm)
{
    wPieces = Array(16);
    bPieces = Array(16);
    wMaterial = wm;
    bMaterial = bm;

    xMaterial = CVmMaterial();
	xMaterial.ambient   = [0.5, 0.5, 0.5, 1.0]; //red
	xMaterial.diffuse   = [1, 0.1, 0.1, 1.0];
	xMaterial.specular  = [0.1, 0.1, 0.1, 0.5];
	//xMaterial.emission = [0.5, 0.1, 0.1];
	xMaterial.shininess = 0;

    corner = c;
    dimension = d;

    eatedCounters = {0,0};

    cbMatrix = Array(64);

    isDropping = Array(32);
}
/*
—— a  b  c  d  e  f  g  h
8 ║♜ ♞ ♝ ♛ ♚ ♝ ♞ ♜
7 ║♟ ♟ ♟ ♟ ♟ ♟ ♟ ♟
6 ║… … … … … … … … … … …
5 ║… … … … … … … … … … …
4 ║… … … … … … … … … … …
3 ║… … … … … … … … … … …
2 ║♙ ♙ ♙ ♙ ♙ ♙ ♙ ♙
1 ║♖ ♘ ♗ ♕ ♔ ♗ ♘ ♖
—— a  b  c  d  e  f  g  h
*/
function ChessBoard::Init()
{
    var letters = {"A", "B", "C", "D", "E", "F", "G", "H"};

    wPieces[0] = ChessPiece(CP_TOWER, AHto64("A", 1), CP_W, wMaterial);
	wPieces[1] = ChessPiece(CP_TOWER, AHto64("H", 1), CP_W, wMaterial);
	wPieces[2] = ChessPiece(CP_HORSE, AHto64("B", 1), CP_W, wMaterial, false);
	wPieces[3] = ChessPiece(CP_HORSE, AHto64("G", 1), CP_W, wMaterial, true);
	wPieces[4] = ChessPiece(CP_BISHOP, AHto64("C", 1), CP_W, wMaterial);
	wPieces[5] = ChessPiece(CP_BISHOP, AHto64("F", 1), CP_W, wMaterial);
	wPieces[6] = ChessPiece(CP_QUEEN, AHto64("D", 1), CP_W, wMaterial);
	wPieces[7] = ChessPiece(CP_KING, AHto64("E", 1), CP_W, wMaterial);

    for(var i = 0; i < 8; i++)
        wPieces[i+8] = ChessPiece(CP_PAWN, AHto64(letters[i], 2), CP_W, wMaterial);

    bPieces[0] = ChessPiece(CP_TOWER, AHto64("A", 8), CP_B, bMaterial);
	bPieces[1] = ChessPiece(CP_TOWER, AHto64("H", 8), CP_B, bMaterial);
	bPieces[2] = ChessPiece(CP_HORSE, AHto64("B", 8), CP_B, bMaterial, false);
	bPieces[3] = ChessPiece(CP_HORSE, AHto64("G", 8), CP_B, bMaterial, true);
	bPieces[4] = ChessPiece(CP_BISHOP, AHto64("C", 8), CP_B, bMaterial);
	bPieces[5] = ChessPiece(CP_BISHOP, AHto64("F", 8), CP_B, bMaterial);
	bPieces[6] = ChessPiece(CP_QUEEN, AHto64("D", 8), CP_B, bMaterial);
	bPieces[7] = ChessPiece(CP_KING, AHto64("E", 8), CP_B, bMaterial);

    for(var i = 0; i < 8; i++)
        bPieces[i+8] = ChessPiece(CP_PAWN, AHto64(letters[i], 7), CP_B, bMaterial);

    for(var i=0; i<16; i++)
        {
            wPieces[i].SetXYPos(corner, dimension);
            isDropping[i] = false;
            cbMatrix[wPieces[i].position] = wPieces[i];

            bPieces[i].SetXYPos(corner, dimension);
            isDropping[i+16] = false;
            cbMatrix[bPieces[i].position] = bPieces[i];
            //OutputLN(cbMatrix[32] == Void);
        }
}

function ChessBoard::DrawPieces(flag)
{
    for(var i = 0; i<16; i++)
    {
        wPieces[i].Draw(flag);
        bPieces[i].Draw(flag);
    }
}

function ChessBoard::FindTouched(finger)
{
    for(var i=0; i<16; i++)
    {
        if(wPieces[i].obj.IsCollidingBBox(finger))
            return i;

        if(bPieces[i].obj.IsCollidingBBox(finger))
            return i+16;
    }
    return -1;
}

function ChessBoard::DropPieces()
{
    for(var i = 0; i<32; i++)
    {
        var p = GetPieceFrom32id(i);//i < 16 ? wPieces[i] : bPieces[i-16];
        if(isDropping[i])
        {
            var  drop_step = 75;
			var pos = p.obj.GetPosition();
            var cbStep = dimension/8;

            var distX = ((pos[0]-corner[0]) % cbStep) - p.GetOffSet(dimension);
            var distY = pos[1];
            var distZ = ((pos[2]-corner[2]) % cbStep) - p.GetOffSet(dimension);

            var decrX = 0.0;
            var decrY = 0.0;
            var decrZ = 0.0;

            if(distX != 0)
            {
                if(0.1 < distX)
					decrX = distX/drop_step;
				else
					decrX = distX;
            }
            if(distZ != 0)
            {
                if(0.1 < distZ)
					decrZ = distZ/drop_step;
				else
					decrZ = distZ;
            }

            if(distY > 0)
			{
				if(0.1 < distY)
					decrY = distY/drop_step;
				else
					decrY = distY;
			}
			else
                isDropping[i] = false;

            p.obj.SetPosition(pos[0] - decrX, pos[1] - decrY, pos[2] - decrZ);
        }
    }
}

function ChessBoard::IsValidDropPosition(p)
{
    //var p = GetPieceFrom32id(id);
    var newPos = GetPosFromXY(p.obj.GetPosition());
    if(p.position == newPos || cbMatrix[newPos] == Void || cbMatrix[newPos].color != p.color)
        return true;
    else
        return false;
}

function ChessBoard::DropToNewPosition(id)
{
    var p = GetPieceFrom32id(id);
    cbMatrix[p.position] = Void;
    OutputLN(p.position);
    var newPos = GetPosFromXY(p.obj.GetPosition());

    if(!IsValidDropPosition(p))
        return false;
    else
    {
        isDropping[id] = true;
        p.position = newPos;
        OutputLN(p.position);
        if(cbMatrix[newPos] != Void && cbMatrix[newPos].color != p.color)
            EatPieceIn(newPos);
        cbMatrix[newPos] = p;
        return true;
    }

}

function ChessBoard::EatPieceIn(pos)
{
    var p = cbMatrix[pos];
    var c = p.color;
    var e = eatedCounters[c];
    var posX = (c==CP_W ? corner[0] + (e*4)%8 : - corner[0] - (e*4)%8);
    var posZ = (c==CP_W ? corner[0] - 4 - (e<8?0:4) : - corner[0] + 4 + (e<8?0:4));
    p.obj.SetPosition(posX, 2, posZ);
    eatedCounters[c] = e+1;
    p.position = -1;
}

function ChessBoard::GetPiecePosition(id)
{
    var p = GetPieceFrom32id(id); //id < 16 ? wPieces[id] : bPieces[id - 16];
    return p.obj.GetPosition();
}

function ChessBoard::FreeMovePiece(id, pos)
{
    var p = GetPieceFrom32id(id); //id < 16 ? wPieces[id] : bPieces[id - 16];
    //TODO: fix, if I move a piece below the board...
    p.obj.SetPosition([pos[0], (pos[1]>0? pos[1]: 0), pos[2]]);
    if(IsValidDropPosition(p))
        p.obj.ForceMaterial();
    else
        p.obj.ForceMaterial(xMaterial);
}

function ChessBoard::GetPieceFrom32id(id)
{
    return id < 16 ? wPieces[id] : bPieces[id - 16];
}

function ChessBoard::GetPosFromXY(p)
{
    var cbStep = dimension/8;
    var x = Int((p[0]+16) / cbStep);
    var z = Int((p[2]+16) / cbStep);

    return x*8 + z;
}

function ChessBoard::CanMoveTo(color, dest)
{
    if(dest < 0 || dest > 63)
        return false;

    if(cbMatrix[dest] == Void)
        return true;
    else if (cbMatrix[dest].color != color)
        return true;
    else
        return false;
}

function ChessBoard::LegalMoves(p)
{
    var startPos = p.position;
    var endPos = startPos;

    var type = p.type;
    var color = p.color;

    var w = (color == CP_W);

    var result = Array(64);
    result[startPos] = true;

    switch (type)
    {
        case CP_PAWN: //TODO:en passant
            if(w)
            {
                //forward
                if(CalcNewPos(startPos, 1, 0, &endPos) && CanMoveTo(color, endPos))
                {
                    result[endPos] = true;

                    //double forward
                    //se ho un pezzo nero davanti non devo poter fare il secondo passo
                    if(startPos < 16 && CalcNewPos(startPos, 2, 0, &endPos) && CanMoveTo(color, endPos) )// && cbMatrix[endPos-8].color != color)
                        result[endPos] = true;
                }

                //left eat
                if(CalcNewPos(startPos, 1, -1, &endPos) && CanMoveTo(color, endPos) && cbMatrix[endPos] != Void)
                    result[endPos] = true;

                //right eat
                if(CalcNewPos(startPos, 1, 1, &endPos) && CanMoveTo(color, endPos) && cbMatrix[endPos] != Void)
                    result[endPos] = true;

            }
            else
            {
                //forward
                if(CalcNewPos(startPos, -1, 0, &endPos) && CanMoveTo(color, endPos))
                {
                    result[endPos] = true;

                    //double forward
                    if(startPos > 47  && CalcNewPos(startPos, -2, 0, &endPos) && CanMoveTo(color, endPos))
                        result[endPos] = true;
                }

                //left eat
                if(CalcNewPos(startPos, -1, -1, &endPos) && CanMoveTo(color, endPos) && cbMatrix[endPos] != Void)
                    result[endPos] = true;

                //right eat
                if(CalcNewPos(startPos, -1, 1, &endPos) && CanMoveTo(color, endPos) && cbMatrix[endPos] != Void)
                    result[endPos] = true;
            }
            return result;
            break;

        case CP_HORSE:
            //TODO:better code...
            if(CalcNewPos(startPos, 1, -2, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, 2, -1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, 2, 1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, 1, 2, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, -1, 2, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, -2, 1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, -2, -1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, -1, -2, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            return result;
            break;

        case CP_BISHOP:
        //same as first half of queen, drop down
        case CP_QUEEN:
            //top left
            for(var i = 1; CalcNewPos(startPos, i, -i, &endPos) && CanMoveTo(color, endPos); i++)
            {
                result[endPos] = true;
                if(cbMatrix[endPos] != Void && cbMatrix[endPos].color != color)
                    break;//stop at first enemy
            }

            //top right
            for(var i = 1; CalcNewPos(startPos, i, i, &endPos) && CanMoveTo(color, endPos); i++)
            {
                result[endPos] = true;
                if(cbMatrix[endPos] != Void && cbMatrix[endPos].color != color)
                    break;//stop at first enemy
            }

            //bottom left
            for(var i = 1; CalcNewPos(startPos, -i, -i, &endPos) && CanMoveTo(color, endPos); i++)
            {
                result[endPos] = true;
                if(cbMatrix[endPos] != Void && cbMatrix[endPos].color != color)
                    break;//stop at first enemy
            }

            //bottom right
            for(var i = 1; CalcNewPos(startPos, -i, i, &endPos) && CanMoveTo(color, endPos); i++)
            {
                result[endPos] = true;
                if(cbMatrix[endPos] != Void && cbMatrix[endPos].color != color)
                    break;//stop at first enemy
            }
        //don't break or return, we fall down for the others movements shared with rook
        if(type == CP_BISHOP)
            return result;
        case CP_TOWER:
            //left
            for(var i = 1; CalcNewPos(startPos, 0, -i, &endPos) && CanMoveTo(color, endPos); i++)
            {
                result[endPos] = true;
                if(cbMatrix[endPos] != Void && cbMatrix[endPos].color != color)
                    break;//stop at first enemy
            }

            //right
            for(var i = 1; CalcNewPos(startPos, 0, i, &endPos) && CanMoveTo(color, endPos); i++)
            {
                result[endPos] = true;
                if(cbMatrix[endPos] != Void && cbMatrix[endPos].color != color)
                    break;//stop at first enemy
            }


            //up
            for(var i = 1; CalcNewPos(startPos, i, 0, &endPos) && CanMoveTo(color, endPos); i++)
            {
                result[endPos] = true;
                if(cbMatrix[endPos] != Void && cbMatrix[endPos].color != color)
                    break;//stop at first enemy
            }


            //down
            for(var i = 1; CalcNewPos(startPos, -i, 0, &endPos) && CanMoveTo(color, endPos); i++)
            {
                result[endPos] = true;
                if(cbMatrix[endPos] != Void && cbMatrix[endPos].color != color)
                    break;//stop at first enemy
            }


            return result;
            break;

        case CP_KING:
            //TODO:better code... chek if the move put the King under attack

            if(CalcNewPos(startPos, 1, -1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, 1, 0, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, 1, 1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, 0, -1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, 0, 1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, -1, -1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, -1, 0, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            if(CalcNewPos(startPos, -1, 1, &endPos) && CanMoveTo(color, endPos)) result[endPos] = true;
            return result;
            break;
    }
}

//Given a position, and a increment in rows and colums, write new position
//in result, and retur true if valid, false ow
function ChessBoard::CalcNewPos(pos, r, c, result)
{
        var startRow = Int(pos/8);
        var starCol = pos % 8;

        var endRow = startRow + r;
        var endCol = starCol  + c;

        result = endRow * 8 + endCol;

        if(endRow < 0 || endCol > 7 || endCol < 0 || endRow > 7)
            return false;
        else
            return true;
}
#endif

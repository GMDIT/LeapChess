/* Include s3d symbols */
#include <Script3d.h>
#include <Camera.s3d.h>
#include "ChessSet.s3d"
#include "ChessPiece.s3d"
#include "ChessBoard.s3d"
#include "ChessEngine.s3d"
#include "Materials.s3d"
#include "Skybox.s3d"


/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000;

SET LEAP_PORT = 4200;
SET ENGINE_PORT = 4242;

var browser;
var res_x = 1600;
var res_y = 900;


// TODO: put your global variables here
/*ChessEngine server data */
//var ce_channel;
var ce_data;
var ce;

/* LeapMotion Data */
var lm_channel;
var localhost;
var dataValues = {"0",0,0,0, 0,0,0 ,0,0,0};
//				handID, palmX, palmY, palmZ, f0X, ... f1X...

var gripDistance = 2.5;

/*tracked fingers */
var palm;
var palm_pos = [10,20.0,0.0];

var f0;
var f0_pos = [10,20.0,0.0];

var f1;
var f1_pos = [20,20.0,0.0];

var reduction_factor = 10;



/*chessboard */
var cb;
var hlList = null;
var lglMoves = null;
var playerColor = CP_W;
var endGame = false;

var m_chessboard;
var o_chessboard;

var m_table;
var o_table;

/*Var for drag and drop */
var mov_gripping = false;
var mov_touching = false;
var mov_moving = false;
var mov_offset;
var mov_piece = -1;


var cmdSent = false;

/*Procedural Objects */
var sphere;

/* Camera globals */
var CamPos = [0, 45.0, 45.0];	// camera position
var CamTarget = [0.0, 0.0, 0.0];

/* Light globals */
var Light0;
//var PosL = [0.0, 15.0, -30];	// default light position
var PosL = CamPos;//[-45,40,0]; //CamPos;//[20, 45.0, 15];	// default light position
//var PosL = [-20, 100.0, -15];	// default light position

var Light1;
var PosL1 = [0.0, 15.0, 30];	// default light position

/*******************
** shadow mapping  *
*******************/
var fbo;
var shader;
// additional OpenGL constants
#define GL_DEPTH_COMPONENT16	0x81A5
#define GL_DEPTH_COMPONENT24	0x81A6
#define GL_DEPTH_COMPONENT32	0x81A7
// a couple of handy application constants
#define SCENE_CAMERA 0
#define LIGHT_CAMERA 1

var shader_name = "adows.sh";
/*****************************/

/* Function declarations */
function CameraMoveMouse();
function DrawGrid(col, size);

function DrawGroundLine(size, pos, color, centered);
function DrawHighlightSquares();
function CompressArray(source);

function RenderOnTexture();
function FillTextureMatrix();
function show_fbo();


function OnDownload()
{
	// TODO: download your resources here
	// E.g.: FileDownload("resource.ext");

	//FileDownload("Data.zip");	// Download di un unico archivio contenente le mesh e le texture
	FileDownload("chessSet.zip");
	FileDownload("textures.zip");
	FileDownload("g_lowres_skybox.zip");

	FileDownload(shader_name);
}

function OnInit(params)
{
	SetFrameRate(60);
	SetAmbientLight(0.2,0.2,0.1);

		/* initialize camera */
	CameraGetCurrent().SetPosition(CamPos);
			//CameraGetCurrent().SetDirection(1, 1, 0);
	CameraGetCurrent().SetTarget(CamTarget);
			//SetScreenResolution(1280, 720);
	//CameraSetPosition(PosL);
	//CameraSetTarget(CamTarget);

	browser = CVmWebBrowser();
	//browser.FullScreen(true);
	browser.SetSize(res_x, res_y);

	/* initialize light */
	Light0 = CVmLight();
	Light0.SetPosition(PosL);
	//Light0.SetDiffuse(0.65, 0.7, 0.5);
	Light0.SetDiffuse(1, 1, 1);
	Light0.SetAmbient(0.5, 0.5,0.55);
	Light0.Enable();

	Light1 = CVmLight();
	Light1.SetPosition(CamPos);
	Light1.SetAmbient(0.5, 0.5, 0.6);
	Light1.Enable();


	//sm
	fbo = CVmFbo(VR_FBO_SHADOW, 4096, 4096, GL_DEPTH_COMPONENT);
	shader = CVmShaderProgram(shader_name);

	// TODO: put your initialization code here

	/*Connecting to Chess Engine Server*/
	ce = ChessEngine(ENGINE_PORT);
	ce.Connect();

	/*Connectin to LeapMotionServer */
	lm_channel = NetCreateChannel(LEAP_PORT, 0, VR_NO_BLOCKING);
	OutputLN(lm_channel);

	/*Init fingers */

	/*Generating the sphere */
	var num_seg = 10;
	var radius = 0.7;
	var hemisphere = 1;  //0.5= hemisphere, 1= sphere
	var sphere_mesh = CVmNewMesh(VRP_SPHERE , num_seg, radius, hemisphere);
	sphere_mesh.SetMaterial(MGetBlue());
	palm = CVmObj();
	palm.LinkToMesh(sphere_mesh);


	var sphere_mesh_1 = CVmNewMesh(VRP_SPHERE , num_seg, radius, hemisphere);
	sphere_mesh_1.CenterBoundingBox();
	sphere_mesh_1.SetMaterial(MGetGreen());
	f0 = CVmObj(sphere_mesh_1);
	//f0.LinkToMesh(sphere_mesh_1);

	var sphere_mesh_2 = CVmNewMesh(VRP_SPHERE , num_seg, radius, hemisphere);
	sphere_mesh_2.CenterBoundingBox();
	sphere_mesh_2.SetMaterial(MGetRed());
	f1 = CVmObj(sphere_mesh_2);
	//f1.LinkToMesh(sphere_mesh_2);

	m_chessboard = CVMNewMesh("chessboard.aam");
	m_chessboard.CenterBoundingBox();
	o_chessboard = CVmObj(m_chessboard);
	o_chessboard.Normalize(32);
	o_chessboard.SetPosition([0,-0.3,0]);
	o_chessboard.Rotate(90, 0, 1, 0);

	//m_table = CVMNewMesh("woodenRoundTable.aam");
	m_table = CVMNewMesh("octagonalTable.aam");
	m_table.CenterBoundingBox();
	//m_table.SetMaterial(m_white);
	o_table = CVmObj(m_table);
	o_table.Normalize(50);
	o_table.SetPosition([0,-20,0]);

	cb = ChessBoard([-16,0,-16], 32, MGetWhite(), MGetBlack());
	cb.Init();
	//OutputLN(cb.GenerateFENChessboard(CP_W));

	CameraActivate(LIGHT_CAMERA);
	CameraSetPosition(PosL);
	CameraSetTarget([0, 0, 0]);

	CameraActivate(SCENE_CAMERA);

	LoadSkyboxTextures();
}

function OnFrame()
{
	/******************
	*      UPDATE     *
	*******************/

	palm.SetPosition(palm_pos);
	f0.SetPosition(f0_pos);
	f1.SetPosition(f1_pos);

	cb.OnFrame();

	if(!endGame)
	{
		endGame = cb.IsCheckMate(cb.turn);
		CameraMoveMouse();
	}
	else
	{
		OutputLN("Checkmate! ", cb.turn == CP_W ? "Black " : "White ", "win!!!");
		CameraSetPosition(vectorRotate(0.3, 0, 1, 0,CameraGetPosition()));
	}

	//OutputLN(modulus(f1_pos - f0_pos));

	if(cb.turn == playerColor)
	{
		//Check if gripping
		if(modulus(f1_pos - f0_pos) < gripDistance)
		{
			f0.forceMaterial(MGetBlue());
			f1.forceMaterial(MGetBlue());
			mov_gripping = true;
		}
		else
		{
			f0.forceMaterial();
			f1.forceMaterial();
			mov_gripping = false;
		}


		//Check if and which piece I'm touching
		mov_touching = false;
		//mov_piece = -1;
		var tmp = cb.FindTouched(f0, playerColor);
		if(tmp != -1)
		{
			mov_touching = true;
			if(!mov_moving)
				mov_piece = tmp;
		}

		if(mov_gripping && mov_touching && !mov_moving) //start moving the piece
		{
			mov_offset = f0.GetPosition() - cb.GetPiecePosition(mov_piece);
			mov_moving = true;
			OutputLN("Star Moving: ", mov_offset, mov_piece);
			lglMoves = cb.LegalMoves(cb.GetPieceFrom32id(mov_piece), false);
			hlList = CompressArray(lglMoves);
		}
		else if ((!mov_gripping || !mov_touching) && mov_moving) //stop moving piece
		{
			if(cb.DropToNewPosition(mov_piece, lglMoves))
			{
				mov_moving = false;
				mov_piece = -1;
				lglMoves = null;
				hlList = null;
			}
			else
				cb.FreeMovePiece(mov_piece, f0.GetPosition() - mov_offset, lglMoves);
		}
		else if(mov_moving)
		{
			cb.FreeMovePiece(mov_piece, f0.GetPosition() - mov_offset, lglMoves);
		}
	}
	else //cb.turn != playerColor
	{
		var cmd;

		if(!cmdSent)
		{
			if(cb.totalMovesCounter == 1)
				cmd = Sprintf("position startpos moves %s", cb.latestMove[2]);
			else
				cmd = Sprintf("position fen %s moves %s", cb.GenerateFENChessboard(), cb.latestMove[2]);

			OutputLN(cmd);
			ce.Send(cmd);
			//NetSendToTCP(ce_channel, cmd);
			OutputLN("CMD sent");
			cmdSent = true;
		}
		else if (!cb.isDropping) //wait for the dropping pieces
		{
			ce_data = ce.Receive();//NetReceiveFromTCP(ce_channel);
			OutputLN("<< " + ce_data);

			var p;
			lglMoves = cb.MakeMovetextMove(ce_data);
			if(cb.IsCheck(cb.turn, &p))
				lglMoves[p] = 2;
			hlList = CompressArray(lglMoves);
			cmdSent = false;
		}
	}

	/* manage camera */
	//CameraMoveMouse();

	//OutputLN(CameraGetPosition());
	//OutputLN(CameraGetRotationMatrix());
	//Light0.SetPosition(CameraGetPosition());	// Sposto la luce ogni volta nella posizione corrente della camera


	/******************
	*      DRAW       *
	*******************/

	//Shadow Mapping
	RenderOnTexture();
	CameraActivate(SCENE_CAMERA);


	/*Drawing Scene */
	SceneBegin();
		RenderSkybox();

		if(mov_moving)
			DrawGroundLine(cb.GetPieceFrom32id(mov_piece).myDim, cb.GetPiecePosition(mov_piece), [0.7, 0.9, 0.7], true);
		else
			DrawGroundLine(1, f0.GetPosition(), [0.1, 0.1, 0.9], false);

		palm.Draw();

		FillTextureMatrix();
		//glCullFace(GL_FRONT);
		glMatrixMode(GL_MODELVIEW);
		//glCullFace(GL_BACK);

		shader.Start();
			SetActiveTexture(fbo);
			shader.SetParameter("shadowMap", 0);

			cb.DrawPieces();

			f0.Draw();
			f1.Draw();

			o_table.Draw();
			o_chessboard.Draw();

		shader.Stop();

		//Draw transparent objs
		if(hlList != null)
			DrawHighlightSquares();

	SceneEnd();
}

function DownloadReady(RequestID)
{
	// TODO
}

function OnTimer()
{
	//receive packet
	if(NetDataReady(lm_channel))
	{
		var data = "";
		var recIp = "";
		data = NetReceiveFrom(lm_channel, &recIP);
		Sscanf(data,"%s (%f, %f, %f)(%f, %f, %f)(%f, %f, %f)", &dataValues[0], &dataValues[1],&dataValues[2],&dataValues[3],&dataValues[4],&dataValues[5],&dataValues[6], &dataValues[7],&dataValues[8],&dataValues[9] );

		palm_pos = [-dataValues[3] / reduction_factor, dataValues[2]/ reduction_factor -20, dataValues[1]/ reduction_factor];
		f0_pos = [-dataValues[6] / reduction_factor, dataValues[5]/ reduction_factor -20, dataValues[4]/ reduction_factor];
		f1_pos = [-dataValues[9] / reduction_factor, dataValues[8]/ reduction_factor -20, dataValues[7]/ reduction_factor];
	}

}


function OnEvent(eventID, wparam, lparam){
	// TODO: put your events handling code here
}

function OnError(){
	// TODO: put your errors handling code here
}


function OnExit()
{
	// TODO: put your cleanup code here
}



// Camera manager (using mouse)
function CameraMoveMouse()
{
	CameraMoveMouse_Target();
}

function DrawGroundLine(size, pos, color, centered)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);

	var x, z, c;
	c = size / 2;
	//TODO:fix
	if(centered)
	{
	    x = Int((pos[0]+c+16) / 4) * 4 + 2 - 16;
	    z = Int((pos[2]+c+16) / 4) * 4 + 2 - 16 ;
	}

	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(color);
	var max = pos[1];
	var min = 0;

	glBegin(GL_LINES);
	if(centered)
	{
		glVertex(pos[0] + c, max, pos[2] + c);
		glVertex(x, min, z);

	}
	else
	{
		glVertex(pos[0] + c, max, pos[2] + c);
		glVertex(pos[0] + c, min, pos[2] + c);
	}


	glEnd();

	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}

function DrawHighlightSquares()
{
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);

	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glEnable(GL_BLEND);
	var colors = {[0.2,1,0.2,0.4], [0.2,1,0.2,0.9], [1,0.2,0.2,0.9]};
	glColor([0.2,1,0.2,0.9]);

	var posX, posZ;
	var dim = hlList[0];
	var hlSquares = hlList[1];
	glBegin(GL_QUADS);
		for (var i = 0; i < dim; i++)
		{
			//TODO: parametrizzare
			posX = Int(hlSquares[i][0]/8) * 4 - 16;
			posZ = (hlSquares[i][0]%8) * 4 - 16;

			glColor(colors[hlSquares[i][1]]);

			glVertex(posX + 0.2, 0.2, posZ + 0.2);
			glVertex(posX + 0.2, 0.2, posZ + 3.8);
			glVertex(posX + 3.8, 0.2, posZ + 3.8);
			glVertex(posX + 3.8, 0.2, posZ + 0.2);
		}
	glEnd();
	glDisable(GL_BLEND);
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}

function CompressArray(source)
{
	var dim = 0;
	var result = Array(32);
	for(var i = 0; i < 64; i++)
	{
		if(source[i] != Void)
		{
			result[dim] = {i, source[i]};
			dim++;
		}
	}
	return {dim, result};
}

function DrawGrid(col, size)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);

	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;
	var step = size / 8.0;

	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, 0, max);
			glVertex(i, 0, min);

			glVertex(max, 0, i);
			glVertex(min, 0, i);
		}
	glEnd();

	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}


/****************************
| shadow mapping functions  |
****************************/
function show_fbo()
{
	glPushAttrib(GL_LIGHTING_BIT | GL_CURRENT_BIT);

	glDisable(GL_LIGHTING);
	glColor(1.0, 1.0, 1.0, 1.0);

	SetActiveTexture(fbo);

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	glTranslate(-1.5, -1.5, -2.5);
	//glScale(0.5, 0.5, 1.0);

	glBegin(GL_QUADS);
		glTexCoord(0.0, 0.0);
		glVertex(0.0, 0.0, 0.0);

		glTexCoord(1.0, 0.0);
		glVertex(1.0, 0.0, 0.0);

		glTexCoord(1.0, 1.0);
		glVertex(1.0, 1.0, 0.0);

		glTexCoord(0.0, 1.0);
		glVertex(0.0, 1.0, 0.0);
	glEnd();

	glPopMatrix();

	glPopAttrib();
}

// light projection and modelview matrices
var light_mat_proj;
var light_mat_modelview;

function RenderOnTexture()
{
	CameraActivate(LIGHT_CAMERA);

	/*
	 * First of all, you have to notify your intention
	 * to draw on the offscreen framebuffer you have created
	 * (that is, render to texture)
	 */
	fbo.Start();

	/*
	 * Then, you start drawing as usual in XVR
	 */
	SceneBegin();
		/*
		 * Retrieve the modelview and projection matrix of the light
		 * and save them; of course if the light is fixed, this is
		 * needed only once
		 */
		light_mat_proj      = glGet(GL_PROJECTION_MATRIX);
		light_mat_modelview = glGet(GL_MODELVIEW_MATRIX);

		/*
		 * Polygon offset is needed in order to avoid artifacts in the
		 * final image due to low precision of depth buffer values
		 */
		glEnable(GL_POLYGON_OFFSET_FILL);
		glPolygonOffset(2, 2);
			/*
			 * Here, draw all the objects that should CAST shadows
			 */
			 f0.Draw(VR_NO_TEXTURE);
			 f1.Draw(VR_NO_TEXTURE);
			 o_chessboard.Draw(VR_NO_TEXTURE);

			cb.DrawPieces(VR_NO_TEXTURE);
			//for(var i = 0; i < 16; i++)
			//	pieces[i].Draw(VR_NO_TEXTURE);


		glDisable(GL_POLYGON_OFFSET_FILL);

	SceneEnd();

	/*
	 * Tell XVR that you are done with the offscreen framebuffer
	 * and that subsequent draw operations should occur on the screen
	 */
	fbo.Stop();
}

function FillTextureMatrix()
{
	glMatrixMode (GL_TEXTURE);

	/*
	 * First of all, we have to clamp the values in the [0.0,1.0] range
	 * instead of the [-1.0,1.0] we obtain from the view matrices
	 */
	glLoadIdentity();
	glTranslate(0.5, 0.5, 0.5);
	glScale(0.5, 0.5, 0.5);

	/*
	 * Next, multiply by the previously retrieved light matrices
	 */
	glMultMatrix(light_mat_proj);
	glMultMatrix(light_mat_modelview);

	/*
	 * Finally, we multiply by the inverse of the *current* modelview matrix
	 * This is needed because it is already included in each vertex own modelview
	 */
	var s_mat_m = glGet(GL_MODELVIEW_MATRIX);

	/*
	 * This matrix should always be invertible, but still...
	 */
	//if (! InvertMatrix(&s_mat_m))
		//Quit("Singular view matrix!");

	s_mat_m = MatrixInverse_4(s_mat_m);
	glMultMatrix(s_mat_m);
}
